<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/1.2.7/marked.min.js" integrity="sha512-Sl04EWeJ0QgILm83WoubQbZqh71aWLJP8xnswnKSBI37S+ZtrWVtSHmd1YaYYdC1g9PWN1siY7KO2jU3HtCVHA==" crossorigin="anonymous"></script>
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
    <link rel="stylesheet" href="static/style.css">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap"
          rel="stylesheet">
</head>
<body>
<nav class="navbar">
    <div class="navbar-container">
        <a href="#">logo</a>
        <form></form>
    </div>
</nav>
<main>
    <article class="wiki-article">
        <header class="wiki-header">
            <h1>문서제목</h1>
            <div class="wiki-menu-wrapper">
                <div class="wiki-menu">
                    <a href="#">편집</a>
                    <a href="#">역사</a>
                    <a href="#">ACL</a>
                </div>
            </div>
        </header>
        <div id="wiki-content" class="wiki-content">
        </div>
    </article>
</main>
<footer>
    발바닥
</footer>
<script>
    document.getElementById('wiki-content').innerHTML =
        marked(
            '# 1. Java IO\n' +
            '\n' +
            '자바의 데이터는 스트림을 통해서 입출력이 된다. 스트림은 데이터가 단일 방향으로 연속으로 흐르는 것을 의미한다. 출발지에서 나와 도착지로 들어간다는 것을 의미한다.  \n' +
            '\n' +
            '출발지는 파일, 프로그램, 소켓, 키보드 등이 될 수 있다.  \n' +
            '도착지는 화면, 파일, 소켓 등이 될 수 있다.  \n' +
            '\n' +
            '# 2. 입력 스트림 / 출력 스트림\n' +
            '\n' +
            '프로그램이 데이터의 출발지냐 도착지냐에 따라 스트림의 종류가 결정된다.  \n' +
            '\n' +
            '프로그램이 출발지인 경우:\n' +
            '\n' +
            '- 프로그램의 데이터가 모니터로 나감(화면 출력)\n' +
            '- 프로그램의 데이터가 네트워크를 통해 나감(데이터 전송)\n' +
            '- 프로그램의 데이터가 파일로 나감(파일 쓰기)\n' +
            '\n' +
            '프로그램이 도착지인 경우:\n' +
            '\n' +
            '- 키보드에서 입력된 데이터가 프로그램에 도착(키 입력)\n' +
            '- 네트워크 통해 들어온 데이터가 프로그램에 도착(데이터 수신)\n' +
            '- 파일로 부터 들어온 데이터가 프로그램에 도착(파일 읽기)\n' +
            '\n' +
            '스트림은 크게 두 가지 종류로 나뉜다.  \n' +
            '\n' +
            '- 바이트 기반 스트림\n' +
            '- 문자 기반 스트림\n' +
            '\n' +
            '바이트 기반 스트림의 입력 스트림과 출력 스트림의 최상위 클래스는 다음과 같다.  \n' +
            '\n' +
            '- InputStream(abstract)\n' +
            '- OutputStream(abstract)\n' +
            '\n' +
            '문자 기반 스트림의 입력 스트림과 출력 스트림의 최상위 클래스는 다음과 같다.  \n' +
            '\n' +
            '- Reader\n' +
            '- Writer\n' +
            '\n' +
            '## 2.1. InputStream(도착지)\n' +
            '\n' +
            'InputStream은 바이트 기반 입력 스트림의 최상위 클래스다.  \n' +
            '\n' +
            '|리턴 타입|메소드|설명|\n' +
            '|-|-|-|\n' +
            '|int|read()|입력 스트림에서 1바이트 읽고 읽은 바이트 반환|\n' +
            '|int|read(byte[] b)|입력 스트림에서 읽은 바이트를 파라미터로 넘어온 바이트 배열에 저장하고 읽은 바이트 수를 반환|\n' +
            '|int|read(byte[] b, int off, int len)|len개의 바이트만큼 읽고, 파라미터로 넘어온 배열의 b[off]부터 len개를 저장한다. 반환되는 값은 실제로 읽은 바이트 수이기 때문에 len보다 작을 수 있다.|\n' +
            '|void|close()|사용한 자원을 반납하고 입력 스트림을 닫는다. 필수.|\n' +
            '\n' +
            '## 2.2. OutputStream(출발지)\n' +
            '\n' +
            'InputStream은 바이트 기반 출력 스트림의 최상위 클래스다.  \n' +
            '\n' +
            '|리턴 타입|메소드|설명|\n' +
            '|-|-|-|\n' +
            '|void|write(int b)|출력 스트림으로 1바이트 보냄. (int의 끝 바이트)|\n' +
            '|void|write(byte[] b)|출력 스트림으로 b의 데이터를 모두 보냄.|\n' +
            '|void|write(byte[] b, int off, int len)|b[off]부터 len만큼 보냄|\n' +
            '|void|flush()|버퍼에 있는 모든 바이트를 출력함(보냄)|\n' +
            '|void|close()|사용한 자원을 반납하고 출력 스트림을 닫는다. 필수.|\n' +
            '\n' +
            '## 2.3. Reader\n' +
            '\n' +
            'Reader는 문자 기반 입력 스트림의 최상위 클래스다.  \n' +
            '\n' +
            '|리턴 타입|메소드|설명|\n' +
            '|-|-|-|\n' +
            '|int|read()|단 하나의 문자를 읽고 리턴|\n' +
            '|int|read(char[] cbuf)|cbuf에 읽은 문자 배열을 저장하고 읽은 문자 수 리턴|\n' +
            '|int|read(char[] cbuf, int off, int len)|len개의 문자를 읽고 cbuf[off]부터 len개 저장. 읽은 문자 수 리턴|\n' +
            '|void|close()|사용한 자원을 반납하고 입력 스트림을 닫는다. 필수.|\n' +
            '\n' +
            '## 2.4. Writer\n' +
            '\n' +
            'Writer는 문자 기반 출력 스트림의 최상위 클래스다.  \n' +
            '\n' +
            '|리턴 타입|메소드|설명|\n' +
            '|-|-|-|\n' +
            '|void|write(int c)|한 문자를 보냄(c 끝의 2바이트)|\n' +
            '|void|write(char[] cbuf)|cbuf의 모든 문자를 보냄|\n' +
            '|void|write(char[] cbuf, int off, int len)|cbuf[off]부터 len개의 문자를 보냄|\n' +
            '|void|write(String str)|문자열을 보냄|\n' +
            '|void|write(String str, int off, int len)|문자열의 off번째부터 len개 보냄|\n' +
            '|void|flush()|버퍼에 있는 모든 바이트를 출력함(보냄)|\n' +
            '|void|close()|사용한 자원을 반납하고 출력 스트림을 닫는다. 필수.|\n' +
            '\n' +
            '# 3. 파일 입출력\n' +
            '\n' +
            '파일을 읽고 쓰는 방법은 크게 3가지가 있다.  \n' +
            '\n' +
            '- File 클래스\n' +
            '- FileInputStream/FileOutputStream\n' +
            '- FileReader/FileWriter\n' +
            '\n' +
            '## 3.1. File 클래스\n' +
            '\n' +
            '기본적인 사용 방법은 다음과 같다.  \n' +
            '\n' +
            '```java\n' +
            'File file = new File("path/to/file");\n' +
            '```\n' +
            '\n' +
            '대표적으로 많이 사용할 메소드만 정리함.  \n' +
            '\n' +
            '|리턴 타입|메소드|설명|\n' +
            '|-|-|-|\n' +
            '|boolean|exists()|파일 존재 여부|\n' +
            '|boolean|createNewFile()|새 파일 생성|\n' +
            '|File|getParentFile()|부모 디렉토리를 File 객체로 리턴|\n' +
            '|String|getPath()|전체 경로 리턴|\n' +
            '|boolean|isFile()|파일이야?|\n' +
            '|boolean|isDirectory()|디렉토리야?|\n' +
            '|long|length()|파일 크기|\n' +
            '\n' +
            '## 3.2. FileInputStream / FileOutputStream\n' +
            '\n' +
            '간단한 파일 카피 프로그램을 만들어보자.  \n' +
            '\n' +
            '```java\n' +
            'final File fileToCopy = new File("source/file/path");\n' +
            'try (\n' +
            '        final FileInputStream fis = new FileInputStream(fileToCopy);\n' +
            '        final FileOutputStream fos = new FileOutputStream("dest/file/path");\n' +
            ') {\n' +
            '    final byte[] buffer = new byte[4096];\n' +
            '    int result;\n' +
            '    while ((result = fis.read(buffer)) != -1) {\n' +
            '        fos.write(buffer);\n' +
            '        System.out.println("read byte: " + result);\n' +
            '    }\n' +
            '} catch (FileNotFoundException e) {\n' +
            '    System.err.println("파일이 없어요!");\n' +
            '} catch (IOException e) {\n' +
            '    System.err.println("파일을 읽는 도중 문제가 발생했어요!");\n' +
            '}\n' +
            '```\n' +
            '\n' +
            '# 4. 네트워크 입출력 \n' +
            '> 인용구')
    hljs.initHighlightingOnLoad();
</script>

</body>
</html>
